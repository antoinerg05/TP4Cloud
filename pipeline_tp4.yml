trigger:
  branches:
    include:
      - main  # Déclenche le pipeline sur la branche principale

variables:
  azureSubscription: 'SC-TP4'  # Remplace avec ton service de connexion Azure
  functionAppName: 'calcul-interets'
  artifactName: 'drop'

stages:
- stage: Build
  displayName: "Build et Tests"
  jobs:
  - job: Build
    displayName: "Build .NET et Exécution des Tests"
    pool:
      vmImage: "ubuntu-latest"

    steps:
    - task: UseDotNet@2
      displayName: "Utiliser .NET 8"
      inputs:
        packageType: "sdk"
        version: "8.0.x"
        installationPath: $(Agent.ToolsDirectory)/dotnet

    - script: |
        dotnet restore
        dotnet build --configuration Release --no-restore
        dotnet test --configuration Release --no-build --verbosity normal
      displayName: "Restaurer, Compiler et Tester"

    - task: ArchiveFiles@2
      displayName: "Créer l'Archive du Code"
      inputs:
        rootFolderOrFile: "$(System.DefaultWorkingDirectory)"
        includeRootFolder: false
        archiveType: "zip"
        archiveFile: "$(Build.ArtifactStagingDirectory)/$(artifactName).zip"
        replaceExistingArchive: true
        verbose: true
        preserveFilePaths: false  # Ajout pour éviter les erreurs d'accès aux fichiers système


    - publish: "$(Build.ArtifactStagingDirectory)/$(artifactName).zip"
      displayName: "Publier l'Artifact"
      artifact: "drop"

- stage: DeployFunction
  displayName: "Déployer l'Azure Function"
  dependsOn: Build
  jobs:
  - job: Deploy
    displayName: "Déploiement de la Function App"
    pool:
      vmImage: "ubuntu-latest"

    steps:
    - download: current
      artifact: "drop"

    - task: AzureFunctionApp@1
      displayName: "Déployer l'Azure Function"
      inputs:
        azureSubscription: "$(azureSubscription)"
        appType: "functionAppLinux"
        appName: "$(functionAppName)"
        package: "$(Pipeline.Workspace)/drop/$(artifactName).zip"
